package com.todolab.task.repository;

import com.todolab.config.QuerydslConfig;
import com.todolab.support.RepositoryTestSupport;
import com.todolab.task.domain.Task;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.data.jpa.test.autoconfigure.DataJpaTest;
import org.springframework.context.annotation.Import;

import java.time.LocalDateTime;
import java.util.List;

import static org.assertj.core.api.BDDAssertions.then;

@DataJpaTest
@Import(QuerydslConfig.class)
class TaskRepositoryTest extends RepositoryTestSupport {

    @Autowired
    TaskRepository taskRepository;

    @Test
    @DisplayName("일정(Task) 저장 성공")
    void save_success() {
        // given
        LocalDateTime startAt = LocalDateTime.of(2025, 11, 27, 10, 30);
        LocalDateTime endAt = LocalDateTime.of(2025, 11, 27, 11, 30);

        Task task = Task.builder()
                .title("hello")
                .description("desc")
                .startAt(startAt)
                .endAt(endAt)
                .allDay(false)
                .category("일")
                .build();

        // when
        Task saved = taskRepository.save(task);
        flushAndClear();

        // then
        then(saved.getId()).isNotNull();
        then(saved.getTitle()).isEqualTo("hello");
        then(saved.getDescription()).isEqualTo("desc");
        then(saved.getStartAt()).isEqualTo(startAt);
        then(saved.getEndAt()).isEqualTo(endAt);
        then(saved.isAllDay()).isFalse();
        then(saved.getCategory()).isEqualTo("일");
    }

    @Test
    @DisplayName("@PrePersist 를 통해 createdAt 이 자동으로 세팅된다")
    void createdAt_autoGenerated() {
        // given
        Task task = Task.builder()
                .title("created test")
                .description("desc")
                .startAt(LocalDateTime.of(2025, 11, 30, 9, 0))
                .endAt(null)
                .allDay(false)
                .category("공부")
                .build();

        // when
        Task saved = taskRepository.save(task);
        flushAndClear();

        // then
        then(saved.getCreatedAt()).isNotNull();
        then(saved.getCreatedAt()).isBeforeOrEqualTo(LocalDateTime.now());
    }

    @Test
    @DisplayName("findByDateRange()는 조회 범위 [start,end) 와 겹치는 기간 일정도 포함한다")
    void findByDateRange_includes_long_period_task_on_partial_range() {
        // given
        // 조회 범위: 11/02 ~ 11/07(포함) => endExclusive = 11/08 00:00
        LocalDateTime startInclusive = LocalDateTime.of(2025, 11, 2, 0, 0);
        LocalDateTime endExclusive = LocalDateTime.of(2025, 11, 8, 0, 0);

        // A: 11월 전체(11/01~11/30) 기간 일정
        Task a = Task.builder()
                .title("A-11월전체")
                .description("11월 1일부터 30일까지")
                .startAt(LocalDateTime.of(2025, 11, 1, 0, 0))
                .endAt(LocalDateTime.of(2025, 12, 1, 0, 0))
                .allDay(true)
                .category("일")
                .build();

        // 범위 내 단일 일정
        Task b = Task.builder()
                .title("B-단일")
                .description("11/03 단일")
                .startAt(LocalDateTime.of(2025, 11, 3, 10, 0))
                .endAt(null)
                .allDay(false)
                .category("공부")
                .build();

        // 범위 밖(겹침 없음)
        Task c = Task.builder()
                .title("C-비겹침")
                .description("10월 일정")
                .startAt(LocalDateTime.of(2025, 10, 1, 0, 0))
                .endAt(LocalDateTime.of(2025, 10, 2, 0, 0))
                .allDay(true)
                .category("기타")
                .build();

        // 미정(조회 대상 제외)
        Task unscheduled = Task.builder()
                .title("미정")
                .description("미정")
                .startAt(null)
                .endAt(null)
                .allDay(false)
                .category("기타")
                .build();

        taskRepository.saveAll(List.of(a, b, c, unscheduled));
        flushAndClear();

        // when
        List<Task> results = taskRepository.findByDateRange(startInclusive, endExclusive);

        // then
        then(results).extracting("title")
                .contains("A-11월전체", "B-단일");

        then(results).extracting("title")
                .doesNotContain("C-비겹침", "미정");
    }

    @Test
    @DisplayName("findByDateRange()는 전날 시작해 조회 시작일에 걸치는 기간 일정도 포함한다")
    void findByDateRange_includes_crossing_period_task_on_day_range() {
        // given
        // 11/01 하루 조회: [11/01 00:00, 11/02 00:00)
        LocalDateTime startInclusive = LocalDateTime.of(2025, 11, 1, 0, 0);
        LocalDateTime endExclusive = LocalDateTime.of(2025, 11, 2, 0, 0);

        Task crossing = Task.builder()
                .title("crossing")
                .description("10/31~11/01 걸침")
                .startAt(LocalDateTime.of(2025, 10, 31, 9, 0))
                .endAt(LocalDateTime.of(2025, 11, 1, 9, 30))
                .allDay(false)
                .category("기타")
                .build();

        Task boundaryExcluded = Task.builder()
                .title("boundaryExcluded")
                .description("startAt == endExclusive")
                .startAt(LocalDateTime.of(2025, 11, 2, 0, 0))
                .endAt(null)
                .allDay(false)
                .category("기타")
                .build();

        taskRepository.saveAll(List.of(crossing, boundaryExcluded));
        flushAndClear();

        // when
        List<Task> results = taskRepository.findByDateRange(startInclusive, endExclusive);

        // then
        then(results).extracting("title")
                .contains("crossing");

        then(results).extracting("title")
                .doesNotContain("boundaryExcluded");
    }

    @Test
    @DisplayName("findByDateRange()는 조회 범위와 겹치지 않는 기간 일정은 제외한다")
    void findByDateRange_excludes_non_overlapping_period_task() {
        // given
        LocalDateTime startInclusive = LocalDateTime.of(2025, 11, 2, 0, 0);
        LocalDateTime endExclusive = LocalDateTime.of(2025, 11, 8, 0, 0);

        Task nonOverlap = Task.builder()
                .title("nonOverlap")
                .description("겹치지 않음")
                .startAt(LocalDateTime.of(2025, 10, 20, 0, 0))
                .endAt(LocalDateTime.of(2025, 10, 21, 0, 0))
                .allDay(true)
                .category("기타")
                .build();

        taskRepository.save(nonOverlap);
        flushAndClear();

        // when
        List<Task> results = taskRepository.findByDateRange(startInclusive, endExclusive);

        // then
        then(results).extracting("title")
                .doesNotContain("nonOverlap");
    }

    @Test
    @DisplayName("findUnscheduledTask()는 startAt/endAt 둘 다 null인 Task만 조회한다")
    void findUnscheduledTask_only_null_start_end() {
        // given
        Task unscheduled1 = Task.builder()
                .title("u1")
                .description("d1")
                .startAt(null)
                .endAt(null)
                .allDay(false)
                .category("일")
                .build();

        Task scheduled1 = Task.builder()
                .title("s1")
                .description("d2")
                .startAt(LocalDateTime.of(2026, 1, 1, 10, 0))
                .endAt(null)
                .allDay(false)
                .category("일")
                .build();

        Task scheduled2 = Task.builder()
                .title("s2")
                .description("d3")
                .startAt(LocalDateTime.of(2026, 1, 2, 10, 0))
                .endAt(LocalDateTime.of(2026, 1, 2, 11, 0))
                .allDay(false)
                .category("일")
                .build();

        taskRepository.saveAll(List.of(unscheduled1, scheduled1, scheduled2));
        flushAndClear();

        // when
        List<Task> result = taskRepository.findUnscheduledTask();

        // then
        then(result).hasSize(1);
        then(result.getFirst().getTitle()).isEqualTo("u1");
        then(result.getFirst().getStartAt()).isNull();
        then(result.getFirst().getEndAt()).isNull();
    }
}
